@article{Parnas1986,
abstract = {Many have sought a software design process that allows a program to be derived systematically from a precise statement of requirements. It is proposed that, although designing a real product in that way will not be successful, it is possible to produce documentation that makes it appear that the software was designed by such a process. The ideal process and the documentation that it requires are described. The authors explain why one should attempt to design according to the ideal process and why one should produce the documentation that would have been produced by that process. The contents of each of the required documents are outlined.},
author = {Parnas, David Lorge and Clements, Paul C.},
doi = {10.1109/TSE.1986.6312940},
file = {:D$\backslash$:/Mendeley Desktop/06312940.pdf:pdf},
issn = {0098-5589},
journal = {IEEE Transactions on Software Engineering},
keywords = {Computers,Data structures,Documentation,Maintenance engineering,Mathematical model,Programming methods,Software design,bariknier15,documentation,rational design process,software design,software documentation,software engineering,statement of requirements,system documentation},
mendeley-tags = {bariknier15},
month = feb,
number = {2},
pages = {251--257},
shorttitle = {Software Engineering, IEEE Transactions on},
title = {{A rational design process: How and why to fake it}},
volume = {SE-12},
year = {1986}
}

@inproceedings{PerezDeRosso2013,
	abstract = {It is commonly asserted that the success of a software development project, and the usability of the final product, depend on the quality of the concepts that underlie its design. Yet this hypothesis has not been systematically explored by researchers, and conceptual design has not played the central role in the research and teaching of software engineering that one might expect. As part of a new research project to explore conceptual design, we are engaging in a series of case studies. This paper reports on the early stages of our first study, on the Git version control system. Despite its widespread adoption, Git puzzles even experienced developers and is not regarded as easy to use. In an attempt to understand the root causes of its complexity, we analyze its conceptual model and identify some undesirable properties; we then propose a reworking of the conceptual model that forms the basis of (the first version of) Gitless, an ongoing effort to redesign Git and experiment with the effects of conceptual simplifications.},
	author = {{Perez De Rosso}, Santiago and Jackson, Daniel},
	booktitle = {Onward! '13},
	doi = {10.1145/2509578.2509584},
	file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Perez De Rosso, Jackson - 2013 - What's wrong with git.pdf:pdf},
	isbn = 9781450324724,
	keywords = {bariknier15,concept design,concepts,conceptual integrity,conceptual modeling,design,git,onward,onward13,software design,software engineering,usability,version control},
	month = oct,
	pages = {37--52},
	tags = {bariknier15,git,onward,onward13,software engineering},
	title = {{What's wrong with Git?}},	
	year = 2013
}

@article{Wingerd1998,
	abstract = {When deploying new SCM (software configuration management) tools, implementers sometimes focus on perfecting fine-grained activities, while unwittingly carrying forward poor, large-scale practices from their previous jobs or previous tools. The result is a well-executed blunder. This paper promotes some high-level best practices that reflect the authors' experiences in deploying SCM.},
	author = {Wingerd, Laura and Seiwald, Christopher},
	doi = {10.1007/BFb0053878},
	editor = {Magnusson, Boris},
	file = {:D$\backslash$:/Mendeley Desktop/chp\%3A10.1007\%2FBFb0053878.pdf:pdf},
	isbn = {978-3-540-64733-1},
	journal = {System Configuration Management},
	keywords = {bariknier15,version control},
	language = {English},
	pages = {57--66},
	publisher = {Springer Berlin Heidelberg},
	series = {Lecture Notes in Computer Science},
	tags = {bariknier15,version control},
	title = {{High-level best practices in software configuration management}},	
	volume = 1439,
	year = 1998
}

@inproceedings{Chu-Carroll2000,
abstract = {Our work focuses on building tools to support collaborative software development. We are building a new programming environment with integrated software configuration management which provides a variety of features to help programming teams coordinate their work. In this paper, we detail a hierachy-based software configuration management system called Coven, which acts as a collaborative medium for allowing teams of programmers to cooperate. By providing a family of inter-related mechanisms, our system provides powerful support for cooperation and coordination in a manner which matches the structure of development teams.},
author = {Chu-Carroll, Mark C. and Sprenkle, Sara},
booktitle = {FSE '00},
doi = {10.1145/357474.355058},
file = {:D$\backslash$:/Mendeley Desktop/p88-chu-carroll.pdf:pdf},
isbn = {1-58113-205-0},
issn = {01635948},
keywords = {bariknier15,collaborative programming,version control},
mendeley-tags = {bariknier15,version control},
month = nov,
pages = {88--97},
title = {{Coven: Brewing Better Collaboration through Software Configuration Management}},
year = {2000}
}

@inproceedings{Murphy2005,
abstract = {Integrated development environments have been designed and engineered to display structural information about the source code of large systems. When a development task lines up with the structure of the system, the tools in these environments do a great job of supporting developers in their work. Unfortunately, many development tasks do not have this characteristic. Instead, they involve changes that are scattered across the source code and various other kinds of artifacts, including bug reports and documentation. Today's development environments provide little support for working with scattered pieces of a system, and as a result, are not adequately supporting the ways in which developers work on the system. Fortunately, many development tasks do have a structure. This structure emerges from a developer's actions when changing the system. In this paper, we describe how the structure of many tasks crosscuts system artifacts, and how by capturing that structure, we can make it as easy for developers to work on changes scattered across the system's structure as it is to work on changes that line up with the system's structure.},
author = {Murphy, Gail C. and Kersten, Mik and Robillard, Martin P. and \v{C}ubrani\'{c}, Davor},
booktitle = {ECOOP '05},
doi = {10.1007/11531142},
file = {:D$\backslash$:/Mendeley Desktop/chp\%3A10.1007\%2F11531142\_2.pdf:pdf},
isbn = {978-3-540-27992-1},
keywords = {bariknier15,version control},
mendeley-tags = {bariknier15,version control},
month = jul,
pages = {33--48},
title = {{The emergent structure of development tasks}},
year = {2005}
}

@incollection{Chu-Carroll2003,
abstract = {In recent years, new software development methodologies and styles have become popular. In particular, many applications are being developed in the open-source community by groups of loosely coordinated programmers scattered across the globe. This style of widely distributed collaboration creates a suite of new problems for software development. Instead of being able to knock on the door of a collaborator, all communication between programmers working together on a system must be mediated through the computer. But at the same time, the bandwidth available for communication is dramatically more limited than those available to local collaborators. In this paper, we present a new SCM system called Stellation which is specifically designed to address the limits of current SCM systems, particularly when those systems are applied to large projects developed in a geographically distributed environment. Stellation attempts to enhance communication and collaboration between programmers by providing a mechanism called multidimensionality that allows them to share viewpoints on the structure and organization of the system; by providing a hierarchical branching mechanism that allows the granularity of coordination to be varied for different purposes; and by providing a mechanism for integrating programming language knowledge into the system, allowing it to be used for organizational and coordination purposes.},
author = {Chu-Carroll, MarkC. and Wright, James},
booktitle = {Software Configuration Management},
doi = {10.1007/3-540-39195-9\_4},
file = {:D$\backslash$:/Mendeley Desktop/chp\%3A10.1007\%2F3-540-39195-9\_4.pdf:pdf},
isbn = {978-3-540-14036-8},
language = {English},
pages = {40--53},
title = {{Supporting Distributed Collaboration through Multidimensional Software Configuration Management}},
volume = {2649},
year = {2003}
}

@inproceedings{Perry1987,
abstract = {In current change management tools, the actual changes occur outside the tool. In contrast, Infuse concentrates on the actual change process and provides facilities for both managing and coordinating source changes. Infuse provides facilities for automatically structuring the cooperation among programmers, propagating changes, and determining the consistency of changes, and provides a basis for negotiating the resolution of conflicting changes and for iterating over a set of changes.},
author = {Perry, Dewayne E. and Kaiser, Gail E.},
booktitle = {CSC '87},
doi = {10.1145/322917.322963},
file = {:D$\backslash$:/Mendeley Desktop/p292-perry.pdf:pdf},
isbn = {0897912187},
keywords = {bariknier15,version control},
mendeley-tags = {bariknier15,version control},
month = feb,
pages = {292--299},
title = {{Infuse: a tool for automatically managing and coordinating source changes in large systems}},
year = {1987}
}

@inproceedings{Perry1989,
author = {Perry, Dewayne E.},
booktitle = {ICSE '89},
doi = {10.1145/74587.74588},
file = {:D$\backslash$:/Mendeley Desktop/p2-perry.pdf:pdf},
isbn = {0818619414},
keywords = {bariknier15},
mendeley-tags = {bariknier15},
month = may,
pages = {2--11},
title = {{The Inscape environment}},
year = {1989}
}

@inproceedings{Ying2011a,
abstract = {Programmers performing a change task must understand the existing software in addition to performing the actual change. This process is likely to be affected by characteristics of the task. We investigated whether the nature of a task has any relationship with when a programmer edits code during a programming session. We characterized differences in editing behaviour with three types of editing styles: edit-first, edit-last, and edit-throughout. We based our analysis on the interaction history of over 4000 programming sessions collected as part of the development history of open source projects. Our results showed that an enhancement task (as opposed to a bug fix) was less likely to be associated with a high fraction of source code edit events at the beginning of the programming session. To our surprise, we also found that the presence of a stack trace in a bug report did not significantly effect the editing style of the programming session.},
author = {Ying, Annie T.T. and Robillard, Martin P.},
booktitle = {2011 IEEE 19th International Conference on Program Comprehension},
doi = {10.1109/ICPC.2011.35},
file = {:D$\backslash$:/Mendeley Desktop/05970161.pdf:pdf},
isbn = {978-1-61284-308-7},
issn = {1092-8138},
keywords = {Clustering algorithms,Couplings,Development interaction history,History,Mining software archives,Monitoring,Navigation,Program comprehension,Programming,Software,bariknier15,behavioural sciences,bug fix,bug report,development history,edit-first style,edit-last style,edit-throughout style,editing behaviour,editing style,enhancement task,icpc,icpc2011,interaction history,open source projects,program debugging,programmer behaviour,programming,programming session,software engineering,source code editing,stack trace},
mendeley-tags = {bariknier15,icpc,icpc2011},
month = jun,
pages = {31--40},
publisher = {IEEE},
shorttitle = {Program Comprehension (ICPC), 2011 IEEE 19th Inter},
title = {{The Influence of the Task on Programmer Behaviour}},
year = {2011}
}

@inproceedings{Wang2011,
abstract = {With the goal of increasing program readability for easier understanding, coding guidelines often include formatting standards such as indenting loop and conditional branch body statements. Similarly, good programming practice suggests that programmers use blank lines to visibly delineate between code segments that represent different algorithmic steps or high level actions. Unfortunately, programmers do not always follow these guidelines. While editors and IDEs can easily indent code based on syntax, they do not currently support automatic blank line insertion, which presents more significant challenges involving the semantics. This paper presents a heuristic solution to the automatic blank line insertion problem, by leveraging both program structure and naming information to identify "meaningful blocks", consecutive statements that logically implement a high level action. Our tool, SEGMENT, takes as input a Java method, and outputs a segmented version that separates meaningful blocks by vertical spacing. We report on an evaluation of the effectiveness of SEGMENT based on developers' opinions. SEGMENT assists in making users obtain an overall picture of a method's actions and comprehend it quicker r as well as provides hints for internal documentation placement.},
author = {Wang, Xiaoran and Pollock, Lori and Vijay-Shanker, K.},
booktitle = {Working Conference on Reverse Engineering},
doi = {10.1109/WCRE.2011.15},
file = {:D$\backslash$:/Mendeley Desktop/06079773.pdf:pdf},
isbn = {978-1-4577-1948-6},
issn = {1095-1350},
keywords = {Compounds,Encoding,Humans,IDE,Java,Java method,Reverse engineering,SEGMENT,Semantics,Syntactics,automatic blank line insertion problem,automatic formatting,automatic method code segmentation,bariknier15,blank lines,conditional branch body statements,document handling,formatting standards,indenting loop,internal documentation placement,program compilers,program readability,program understanding,readability,software maintenance,software tool,source coding},
language = {English},
mendeley-tags = {bariknier15},
month = oct,
pages = {35--44},
title = {{Automatic Segmentation of Method Code into Meaningful Blocks to Improve Readability}},
year = {2011}
}

@article{Murphy-Hill2012c,
abstract = {Refactoring is widely practiced by developers, and considerable research and development effort has been invested in refactoring tools. However, little has been reported about the adoption of refactoring tools, and many assumptions about refactoring practice have little empirical support. In this paper, we examine refactoring tool usage and evaluate some of the assumptions made by other researchers. To measure tool usage, we randomly sampled code changes from four Eclipse and eight Mylyn developers and ascertained, for each refactoring, if it was performed manually or with tool support. We found that refactoring tools are seldom used: 11 percent by Eclipse developers and 9 percent by Mylyn developers. To understand refactoring practice at large, we drew from a variety of data sets spanning more than 39,000 developers, 240,000 tool-assisted refactorings, 2,500 developer hours, and 12,000 version control commits. Using these data, we cast doubt on several previously stated assumptions about how programmers refactor, while validating others. Finally, we interviewed the Eclipse and Mylyn developers to help us understand why they did not use refactoring tools and to gather ideas for future research.},
author = {Murphy-Hill, Emerson and Parnin, Chris and Black, Andrew P.},
doi = {10.1109/TSE.2011.41},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Murphy-Hill, Parnin, Black - 2012 - How We Refactor, and How We Know It.pdf:pdf},
issn = {0098-5589},
journal = {IEEE Transactions on Software Engineering},
keywords = {Eclipse developers,Java,Mylyn developers,Refactoring,Software tools,bariknier15,floss refactoring,randomly sampled code,refactor,refactoring tools,research and development,root-canal refactoring.,software engineering,software maintenance},
mendeley-tags = {bariknier15,refactor,software engineering},
month = jan,
number = {1},
pages = {5--18},
shorttitle = {Software Engineering, IEEE Transactions on},
title = {{How we refactor, and how we know it}},
volume = {38},
year = {2012}
}

@inproceedings{Kersten2006,
abstract = {When working on a large software system, a programmer typically spends an inordinate amount of time sifting through thousands of artifacts to find just the subset of information needed to complete an assigned task. All too often, before completing the task the programmer must switch to working on a different task. These task switches waste time as the programmer must repeatedly find and identify the information relevant to the task-at-hand. In this paper, we present a mechanism that captures, models, and persists the elements and relations relevant to a task. We show how our task context model reduces information overload and focuses a programmer's work by filtering and ranking the information presented by the development environment. A task context is created by monitoring a programmer's activity and extracting the structural relationships of program artifacts. Operations on task contexts integrate with development environment features, such as structure display, search, and change management. We have validated our approach with a longitudinal field study of Mylar, our implementation of task context for the Eclipse development environment. We report a statistically significant improvement in the productivity of 16 industry programmers who voluntarily used Mylar for their daily work.},
author = {Kersten, Mik and Murphy, Gail C.},
booktitle = {FSE '06},
doi = {10.1145/1181775.1181777},
file = {:D$\backslash$:/Mendeley Desktop/p1-kersten.pdf:pdf},
isbn = {1595934685},
keywords = {IDE,bariknier15,degree-of-interest,interaction history,program views,task management},
mendeley-tags = {bariknier15},
month = nov,
pages = {1--11},
title = {Using task context to improve programmer productivity},
year = {2006}
}


@incollection{Negara2012,
abstract = {Researchers use file-based Version Control System (VCS) as the primary source of code evolution data. VCSs are widely used by developers, thus, researchers get easy access to historical data of many projects. Although it is convenient, research based on VCS data is incomplete and imprecise. Moreover, answering questions that correlate code changes with other activities (e.g., test runs, refactoring) is impossible. Our tool, CodingTracker, non-intrusively records fine-grained and diverse data during code development. CodingTracker collected data from 24 developers: 1,652 hours of development, 23,002 committed files, and 314,085 testcase runs. This allows us to answer: How much code evolution data is not stored in VCS? How much do developers intersperse refactorings and edits in the same commit? How frequently do developers fix failing tests by changing the test itself? How many changes are committed to VCS without being tested? What is the temporal and spacial locality of changes?},
author = {Negara, Stas and Vakilian, Mohsen and Chen, Nicholas and Johnson, RalphE. and Dig, Danny},
booktitle = {ECOOP '12},
doi = {10.1007/978-3-642-31057-7\_5},
file = {:D$\backslash$:/Mendeley Desktop/chp\%3A10.1007\%2F978-3-642-31057-7\_5.pdf:pdf},
isbn = {978-3-642-31056-0},
keywords = {bariknier15},
language = {English},
mendeley-tags = {bariknier15},
pages = {79--103},
title = {{Is it dangerous to use version control histories to study source code evolution?}},
volume = {7313},
year = {2012}
}

@inproceedings{Robbes2008,
abstract = {Our research is driven by the motivation that change must be put in the center, if one wants to understand the complex processes of software evolution. We built a toolset named SpyWare which, using a monitoring plug-in for integrated development environments (IDEs), tracks the changes that a developer performs on a program as they happen. SpyWare stores these first-class changes in a change repository and offers a plethora of productivity-enhancing IDE extensions to exploit the recorded information.},
address = {New York, New York, USA},
author = {Robbes, Romain and Lanza, Michele},
booktitle = {Proceedings of the 13th international conference on Software engineering - ICSE '08},
doi = {10.1145/1368088.1368219},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Robbes, Lanza - 2008 - SpyWare.pdf:pdf},
isbn = {9781605580791},
keywords = {bariknier15,change,modelling,program transformation,visualization},
mendeley-tags = {bariknier15},
month = may,
pages = {847},
publisher = {ACM Press},
title = {{SpyWare}},
year = {2008}
}

@book{Loeliger2012,
author = {Loeliger, Jon and McCullough, Matthew},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Loeliger, McCullough - 2012 - Version Control with Git.pdf:pdf},
edition = 2,
isbn = {9781449316389},
keywords = {book,git},
mendeley-tags = {book,git},
publisher = {O'Reilly Media},
title = {{Version Control with Git}},
year = {2012}
}

@inproceedings{Hayashi2012,
abstract = {This paper proposes a concept for refactoring an edit history of source code and a technique for its automation. The aim of our history refactoring is to improve the clarity and usefulness of the history without changing its overall effect. We have defined primitive history refactorings including their preconditions and procedures, and large refactorings composed of these primitives. Moreover, we have implemented a supporting tool that automates the application of history refactorings in the middle of a source code editing process. Our tool enables developers to pursue some useful applications using history refactorings such as task level commit from an entangled edit history and selective undo of past edit operations.},
author = {Hayashi, Shinpei and Omori, Takayuki and Zenmyo, Teruyoshi and Maruyama, Katsuhisa and Saeki, Motoshi},
booktitle = {ICSM '12},
doi = {10.1109/ICSM.2012.6405336},
file = {:D$\backslash$:/Mendeley Desktop/06405336.pdf:pdf},
isbn = {978-1-4673-2312-3},
issn = {1063-6773},
keywords = {Browsers,Conferences,Electronic mail,History,Software maintenance,Usability,bariknier15,configuration management,edit history,edit operation selective undo,history clarity improvement,history usefulness improvement,refactoring,software configuration management,software maintenance,source code edit primitive history refactoring,task level commit},
mendeley-tags = {bariknier15},
month = sep,
pages = {617--620},
shorttitle = {Software Maintenance (ICSM), 2012 28th IEEE Intern},
title = {{Refactoring edit history of source code}},
year = {2012}
}

@article{Weiser1982a,
abstract={Computer programmers break apart large programs into smaller coherent pieces. Each of these pieces: functions, subroutines, modules, or abstract datatypes, is usually a contiguous piece of program text. The experiment reported here shows that programmers also routinely break programs into one kind of coherent piece which is not coniguous. When debugging unfamiliar programs programmers use program pieces called slices which are sets of statements related by their flow of data. The statements in a slice are not necessarily textually contiguous, but may be scattered through a program.},
  title={Programmers use slices when debugging},
  author={Weiser, Mark},
  journal={Communications of the ACM},
  volume={25},
  number={7},
  pages={446--452},
  year={1982},
  publisher={ACM}
}


@inproceedings{DeLine2012,
abstract={At ICSE 2010, the Code Bubbles team from Brown University and the Code Canvas team from Microsoft Research presented similar ideas for new user experiences for an integrated development environment. Since then, the two teams formed a collaboration, along with the Microsoft Visual Studio team, to release Debugger Canvas, an industrial version of the Code Bubbles paradigm. With Debugger Canvas, a programmer debugs her code as a collection of code bubbles, annotated with call paths and variable values, on a two-dimensional pan-and-zoom surface. In this experience report, we describe new user interface ideas, describe the rationale behind our design choices, evaluate the performance overhead of the new design, and provide user feedback based on lab participants, post-release usage data, and a user survey and interviews. We conclude that the code bubbles paradigm does scale to existing customer code bases, is best implemented as a mode in the existing user experience rather than a replacement, and is most useful when the user has a long or complex call paths, a large or unfamiliar code base, or complex control patterns, like factories or dynamic linking.},
  title={Debugger canvas: Industrial experience with the code bubbles paradigm},
  author={DeLine, Robert and Bragdon, Andrew and Rowan, Kael and Jacobsen, Jens and Reiss, Steven P},
  booktitle={ICSE '12},
  pages={1064--1073},
  year={2012},
}

@inproceedings{DeLine2010a,
abstract = {The user interfaces of today's development environments have a "bento box" design that partitions information into separate areas. This design makes it difficult to stay oriented in the open documents and to synthesize information shown in different areas. Code Canvas takes a new approach by providing an infinite zoomable surface for software development. A canvas both houses editable forms of all of a project's documents and allows multiple layers of visualization over those documents. By uniting the content of a project and information about it onto a single surface, Code Canvas is designed to leverage spatial memory to keep developers oriented and to make it easy to synthesize information.},
author = {DeLine, Robert and Rowan, Kael},
booktitle = {ICSE '10},
doi = {10.1145/1810295.1810331},
isbn = {9781605587196},
keywords = {code bubbles,code canvas,software engineering},
mendeley-tags = {code bubbles,code canvas,software engineering},
month = may,
pages = {207--210},
title = {{Code Canvas}: Zooming towards better development environments},
volume = {2},
year = {2010}
}

@inproceedings{Bragdon2010CodeBubbles,
  title={Code Bubbles: rethinking the user interface paradigm of integrated development environments},
  author={Bragdon, Andrew and Reiss, Steven P and Zeleznik, Robert and Karumuri, Suman and Cheung, William and Kaplan, Joshua and Coleman, Christopher and Adeputra, Ferdi and LaViola Jr, Joseph J},
  booktitle={ICSE '10},
  pages={455--464},
  year={2010},
  organization={ACM}
}

@book{beck2003tdd,
  title={Test-driven development: by example},
  author={Beck, Kent},
  year={2003},
  publisher={Addison-Wesley Professional}
}

@article{Littman1987,
abstract = {Understanding how a program is constructed and how it functions are significant components of the task of maintaining or enhancing a computer program. We have analyzed vidoetaped protocols of experienced programmers as they enhanced a personnel data base program. Our analysis suggests that there are two strategies for program understanding, the systematic strategy and the as-needed strategy. The programmer using the systematic strategy traces data flow through the program in order to understand global program behavior. The programmer using the as-needed strategy focuses on local program behavior in order to localize study of the program. Our empirical data show that there is a strong relationship between using a systematic approach to acquire knowledge about the program and modifying the program successfully. Programmers who used the systematic approach to study the program constructed successful modifications; programmers who used the as-needed approach failed to construct successful modifications. Programmers who used the systematic strategy gathered knowledge about the causal interactions of the program's functional components. Programmers who used the as-needed strategy did not gather such causal knowledge and therefore failed to detect interactions among components of the program.},
author = {Littman, David C. and Pinto, Jeannine and Letovsky, Stanley and Soloway, Elliot},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Littman et al. - 1987 - Mental models and software maintenance.pdf:pdf},
journal = {Journal of Systems and Software},
keywords = {bariknier15,software engineering,software psychology},
mendeley-tags = {bariknier15,software engineering,software psychology},
number = {4},
pages = {341--355},
title = {{Mental models and software maintenance}},
volume = {7},
year = {1987}
}

@inproceedings{Kirinuki2014,
abstract = {Although there is a principle that states a commit should only include changes for a single task, it is not always respected by developers. This means that code repositories often include commits that contain tangled changes. The presence of such tangled changes hinders analyzing code repositories because most mining software repository (MSR) approaches are designed with the assumption that every commit includes only changes for a single task. In this paper, we propose a technique to inform developers that they are in the process of committing tangled changes. The proposed technique utilizes the changes included in the past commits to judge whether a given commit includes tangled changes. If it determines that the proposed commit may include tangled changes, it offers suggestions on how the tangled changes can be split into a set of untangled changes.},
author = {Kirinuki, Hiroyuki and Higo, Yoshiki and Hotta, Keisuke and Kusumoto, Shinji},
booktitle = {ICPC '14},
doi = {10.1145/2597008.2597798},
file = {:D$\backslash$:/Mendeley Desktop/p262-kirinuki.pdf:pdf},
isbn = {9781450328791},
keywords = {Mining software repositories,Tangled changes,Understanding commits,bariknier15,icpc,icpc2014},
mendeley-tags = {bariknier15,icpc,icpc2014},
month = jun,
pages = {262--265},
title = {{Hey! Are you committing tangled changes?}},
year = {2014}
}

@inproceedings{Parnin2008,
abstract = {Software archives are one of the best sources available to researchers for understanding the software development process. However, much detective work is still necessary in order to unravel the software development story. During this process, researchers must isolate changes and follow their trails over time. In support of this analysis, several research tools have provided different representations for connecting the many changes extracted from software archives. Most of these tools are based on textual analysis of source code and use line-based differencing between software versions. This approach limits the ability to process changes structurally resulting in less concise and comparable items. Adoption of structure-based approaches have been hampered by complex implementations and overly verbose change descriptions. We present a technique for expressing changes that is fine-grained but preserves some structural aspects. The structural information itself may not have changed, but instead provides a context for interpreting the change. This in turn, enables more relevant and concise descriptions in terms of software types and programming activities. We apply our technique to common challenges that researchers face, and then we discuss and compare our results with other techniques.},
address = {New York, New York, USA},
author = {Parnin, Chris and G\"{o}rg, Carsten},
booktitle = {Proceedings of the 2008 international workshop on Mining software repositories - MSR '08},
keywords = {bariknier15,bytecode analysis,change pairs,semantic diff},
mendeley-tags = {bariknier15},
month = may,
pages = {51},
publisher = {ACM Press},
title = {{Improving change descriptions with change contexts}},
year = {2008}
}

@inproceedings{Parnin2012,
abstract = {Despite its vast capacity and associative powers, the human brain does not deal well with interruptions. Particularly in situations where information density is high, such as during a programming task, recovering from an interruption requires extensive time and effort. Although modern program development environments have begun to recognize this problem, none of these tools take into account the brain's structure and limitations. In this paper, we present a conceptual framework for understanding the strengths and weaknesses of human memory, particularly with respect to it ability to deal with work interruptions. The framework explains empirical results obtained from experiments in which programmers were interrupted while working. Based on the framework, we discuss programmer information needs that development tools must satisfy and suggest several memory aids such tools could provide. We also describe our prototype implementation of these memory aids.},
author = {Parnin, Chris and Rugaber, Spencer},
booktitle = {ICPC '12},
doi = {10.1109/ICPC.2012.6240479},
file = {:D$\backslash$:/Mendeley Desktop/06240479.pdf:pdf},
isbn = {978-1-4673-1216-5},
issn = {1092-8138},
keywords = {Associative memory,Hippocampus,Humans,Memory management,Monitoring,Neuroscience,Programming,bariknier15,brain,conceptual framework,human brain,human memory strength,human memory weakness,icpc,information density,information needs,interruptions,memory failure,neurophysiology,program development environments,programmer information needs},
mendeley-tags = {bariknier15,icpc},
month = jun,
pages = {123--132},
shorttitle = {Program Comprehension (ICPC), 2012 IEEE 20th Inter},
title = {{Programmer information needs after memory failure}},
year = {2012}
}


@inproceedings{Buse2010,
abstract = {Source code modifications are often documented with log messages. Such messages are a key component of software maintenance: they can help developers validate changes, locate and triage defects, and understand modifications. However, this documentation can be burdensome to create and can be incomplete or inaccurate. We present an automatic technique for synthesizing succinct human-readable documentation for arbitrary program differences. Our algorithm is based on a combination of symbolic execution and a novel approach to code summarization. The documentation it produces describes the effect of a change on the runtime behavior of a program, including the conditions under which program behavior changes and what the new behavior is. We compare our documentation to 250 human-written log messages from 5 popular open source projects. Employing a human study, we find that our generated documentation is suitable for supplementing or replacing 89\% of existing log messages that directly describe a code change.},
author = {Buse, Raymond P.L. and Weimer, Westley R.},
booktitle = {ASE '10},
doi = {10.1145/1858996.1859005},
file = {:D$\backslash$:/Mendeley Desktop/p33-buse.pdf:pdf},
isbn = {9781450301169},
keywords = {bariknier15,code summarization,commit messages,differencing},
mendeley-tags = {bariknier15},
month = sep,
pages = {33--42},
title = {{Automatically documenting program changes}},
year = {2010}
}

@article{Ackerman2000,
abstract = {Over the last 10 years, Computer-Supported Cooperative Work (CSCW) has identified a base set of findings. These findings are taken almost as assumptions within the field. In summary, they argue that human activity is highly flexible, nuanced, and contextualized and that computational entities such as information sharing, roles, and social norms need to be similarly flexible, nuanced, and contextualized. However, current systems cannot fully support the social world uncovered by these findings. In this article I argue that there is an inherent gap between the social requirements of CSCW and its technical mechanisms. The social-technical gap is the divide between what we know we must support socially and what we can support technically. Exploring, understanding, and hopefully ameliorating this social-technical gap is the central challenge for CSCW as a field and one of the central problems for human-computer interaction. Indeed, merely attesting the continued centrality of this gap could be one of the important intellectual contributions of CSCW. I also argue that the challenge of the social-technical gap creates an opportunity to refocus CSCW.},
author = {Ackerman, Mark},
doi = {10.1207/S15327051HCI1523\_5},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Ackerman - 2000 - The Intellectual Challenge of CSCW The Gap Between Social Requirements and Technical Feasibility.pdf:pdf},
issn = {0737-0024},
journal = {Human-Computer Interaction},
keywords = {bariknier15},
mendeley-tags = {bariknier15},
month = sep,
number = {2},
pages = {179--203},
publisher = {L. Erlbaum Associates Inc.},
title = {The Intellectual Challenge of {CSCW}: The Gap Between Social Requirements and Technical Feasibility},
volume = {15},
year = {2000}
}

@inproceedings{Bragdon2010a,
abstract = {Developers spend significant time reading and navigating code fragments spread across multiple locations. The file-based nature of contemporary IDEs makes it prohibitively difficult to create and maintain a simultaneous view of such fragments. We propose a novel user interface metaphor for code understanding based on collections of lightweight, editable fragments called bubbles, which form concurrently visible working sets. We present the results of a qualitative usability evaluation, and the results of a quantitative study which indicates Code Bubbles significantly improved code understanding time, while reducing navigation interactions over a widely-used IDE, for two controlled tasks.},
author = {Bragdon, Andrew and Zeleznik, Robert and Reiss, Steven P. and Karumuri, Suman and Cheung, William and Kaplan, Joshua and Coleman, Christopher and Adeputra, Ferdi and LaViola, Joseph J.},
booktitle = {CHI '10},
doi = {10.1145/1753326.1753706},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Bragdon et al. - 2010 - Code bubbles.pdf:pdf},
isbn = {9781605589299},
keywords = {bariknier15,bubbles,java,multi-view,simultaneous views,source code},
mendeley-tags = {bariknier15},
month = apr,
pages = {2503--2512},
title = {{Code Bubbles: A working set-based interface for code understanding and maintenance}},
year = {2010}
}

@article{Robillard2010a,
abstract = {Software development can be challenging because of the large information spaces that developers must navigate. Without assistance, developers can become bogged down and spend a disproportionate amount of their time seeking information at the expense of other value-producing tasks. Recommendation systems for software engineering (RSSEs) are software tools that can assist developers with a wide range of activities, from reusing code to writing effective bug reports. The authors provide an overview of recommendation systems for software engineering: what they are, what they can do for developers, and what they might do in the future.},
author = {Robillard, Martin and Walker, Robert and Zimmermann, Thomas},
doi = {10.1109/MS.2009.161},
issn = {0740-7459},
journal = {IEEE Software},
keywords = {bariknier15,bug reports,coding tools and techniques,design tools and techniques,development tools,information space,programming environments,recommendation system,recommender systems,software construction tools,software development,software engineering,software tool,software tools,time seeking information,value-producing task},
mendeley-tags = {bariknier15},
month = jul,
number = {4},
pages = {80--86},
shorttitle = {Software, IEEE},
title = {Recommendation Systems for Software Engineering},
volume = {27},
year = {2010}
}

@ONLINE{GitBestPractices,
author = {Ernst,Michael},
title = {Version control concepts and best practices},
month = jul,
year = {2014},
url = {http://homes.cs.washington.edu/~mernst/advice/version-control.html}
}

@ONLINE{SausageMaking,
author = {Robertson, Seth},
title = {Commit Often, Perfect Later, Publish Once: Git Best Practices},
month = feb,
year = {2012},
url = {http://sethrobertson.github.io/GitBestPractices/}
}

@inproceedings{Henley2014,
author = {Henley, Austin Z. and Fleming, Scott D.},
booktitle = {CHI '14},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Henley, Fleming - 2014 - The patchworks code editor.pdf:pdf},
keywords = {chi,code editor,integrated development environment (ide),navigation,patchworks,user study},
mendeley-tags = {chi,patchworks},
month = apr,
pages = {2511--2520},
title = {{The Patchworks code editor}},
year = {2014}
}

@inproceedings{Coblenz2006,
author = {Coblenz, Michael J. and Ko, Andrew J. and Myers, Brad A.},
booktitle = {OOPSLA Workshop: Eclipse '06},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Coblenz, Ko, Myers - 2006 - JASPER.pdf:pdf},
isbn = {1595936211},
keywords = {Eclipse,bariknier15,concerns,natural programming,programmer efficiency,programming environments},
mendeley-tags = {bariknier15},
month = oct,
pages = {65--69},
title = {{JASPER: An Eclipse plug-in to facilitate software maintenance tasks}},
year = {2006}
}

@article{Ko2006,
abstract = {Much of software developers' time is spent understanding unfamiliar code. To better understand how developers gain this understanding and how software development environments might be involved, a study was performed in which developers were given an unfamiliar program and asked to work on two debugging tasks and three enhancement tasks for 70 minutes. The study found that developers interleaved three activities. They began by searching for relevant code both manually and using search tools; however, they based their searches on limited and misrepresentative cues in the code, environment, and executing program, often leading to failed searches. When developers found relevant code, they followed its incoming and outgoing dependencies, often returning to it and navigating its other dependencies; while doing so, however, Eclipse's navigational tools caused significant overhead. Developers collected code and other information that they believed would be necessary to edit, duplicate, or otherwise refer to later by encoding it in the interactive state of Eclipse's package explorer, file tabs, and scroll bars. However, developers lost track of relevant code as these interfaces were used for other tasks, and developers were forced to find it again. These issues caused developers to spend, on average, 35 percent of their time performing the mechanics of navigation within and between source files. These observations suggest a new model of program understanding grounded in theories of information foraging and suggest ideas for tools that help developers seek, relate, and collect information in a more effective and explicit manner},
author = {Ko, Andrew and Myers, Brad and Coblenz, Michael and Aung, Htet},
doi = {10.1109/TSE.2006.116},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Ko et al. - 2006 - An Exploratory Study of How Developers Seek, Relate, and Collect Relevant Information during Software Maintenance Tas.pdf:pdf},
issn = {0098-5589},
journal = {IEEE Transactions on Software Engineering},
keywords = {software engineering},
mendeley-tags = {software engineering},
month = dec,
number = {12},
pages = {971--987},
shorttitle = {Software Engineering, IEEE Transactions on},
title = {An Exploratory Study of How Developers Seek, Relate, and Collect Relevant Information during Software Maintenance Tasks},
volume = {32},
year = {2006}
}
