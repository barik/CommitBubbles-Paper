@inproceedings{PerezDeRosso2013,
	abstract = {It is commonly asserted that the success of a software development project, and the usability of the final product, depend on the quality of the concepts that underlie its design. Yet this hypothesis has not been systematically explored by researchers, and conceptual design has not played the central role in the research and teaching of software engineering that one might expect. As part of a new research project to explore conceptual design, we are engaging in a series of case studies. This paper reports on the early stages of our first study, on the Git version control system. Despite its widespread adoption, Git puzzles even experienced developers and is not regarded as easy to use. In an attempt to understand the root causes of its complexity, we analyze its conceptual model and identify some undesirable properties; we then propose a reworking of the conceptual model that forms the basis of (the first version of) Gitless, an ongoing effort to redesign Git and experiment with the effects of conceptual simplifications.},
	author = {{Perez De Rosso}, Santiago and Jackson, Daniel},
	booktitle = {Onward! '13},
	doi = {10.1145/2509578.2509584},
	file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Perez De Rosso, Jackson - 2013 - What's wrong with git.pdf:pdf},
	isbn = 9781450324724,
	keywords = {bariknier15,concept design,concepts,conceptual integrity,conceptual modeling,design,git,onward,onward13,software design,software engineering,usability,version control},
	month = oct,
	pages = {37--52},
	tags = {bariknier15,git,onward,onward13,software engineering},
	title = {{What's wrong with git?}},	
	year = 2013
}

@article{Wingerd1998,
	abstract = {When deploying new SCM (software configuration management) tools, implementers sometimes focus on perfecting fine-grained activities, while unwittingly carrying forward poor, large-scale practices from their previous jobs or previous tools. The result is a well-executed blunder. This paper promotes some high-level best practices that reflect the authors' experiences in deploying SCM.},
	author = {Wingerd, Laura and Seiwald, Christopher},
	doi = {10.1007/BFb0053878},
	editor = {Magnusson, Boris},
	file = {:D$\backslash$:/Mendeley Desktop/chp\%3A10.1007\%2FBFb0053878.pdf:pdf},
	isbn = {978-3-540-64733-1},
	journal = {System Configuration Management},
	keywords = {bariknier15,version control},
	language = {English},
	pages = {57--66},
	publisher = {Springer Berlin Heidelberg},
	series = {Lecture Notes in Computer Science},
	tags = {bariknier15,version control},
	title = {{High-level best practices in software configuration management}},	
	volume = 1439,
	year = 1998
}

@inproceedings{Chu-Carroll2000,
abstract = {Our work focuses on building tools to support collaborative software development. We are building a new programming environment with integrated software configuration management which provides a variety of features to help programming teams coordinate their work. In this paper, we detail a hierachy-based software configuration management system called Coven, which acts as a collaborative medium for allowing teams of programmers to cooperate. By providing a family of inter-related mechanisms, our system provides powerful support for cooperation and coordination in a manner which matches the structure of development teams.},
author = {Chu-Carroll, Mark C. and Sprenkle, Sara},
booktitle = {FSE '00},
doi = {10.1145/357474.355058},
file = {:D$\backslash$:/Mendeley Desktop/p88-chu-carroll.pdf:pdf},
isbn = {1-58113-205-0},
issn = {01635948},
keywords = {bariknier15,collaborative programming,version control},
mendeley-tags = {bariknier15,version control},
month = nov,
pages = {88--97},
title = {{Coven: Brewing Better Collaboration through Software Configuration Management}},
year = {2000}
}

@inproceedings{Murphy2005,
abstract = {Integrated development environments have been designed and engineered to display structural information about the source code of large systems. When a development task lines up with the structure of the system, the tools in these environments do a great job of supporting developers in their work. Unfortunately, many development tasks do not have this characteristic. Instead, they involve changes that are scattered across the source code and various other kinds of artifacts, including bug reports and documentation. Today's development environments provide little support for working with scattered pieces of a system, and as a result, are not adequately supporting the ways in which developers work on the system. Fortunately, many development tasks do have a structure. This structure emerges from a developer's actions when changing the system. In this paper, we describe how the structure of many tasks crosscuts system artifacts, and how by capturing that structure, we can make it as easy for developers to work on changes scattered across the system's structure as it is to work on changes that line up with the system's structure.},
address = {Berlin, Heidelberg},
author = {Murphy, Gail C. and Kersten, Mik and Robillard, Martin P. and \v{C}ubrani\'{c}, Davor},
booktitle = {ECOOP '05},
doi = {10.1007/11531142},
editor = {Black, Andrew P.},
file = {:D$\backslash$:/Mendeley Desktop/chp\%3A10.1007\%2F11531142\_2.pdf:pdf},
isbn = {978-3-540-27992-1},
keywords = {bariknier15,version control},
mendeley-tags = {bariknier15,version control},
month = jul,
pages = {33--48},
publisher = {Springer Berlin Heidelberg},
title = {{The emergent structure of development tasks}},
volume = {3586},
year = {2005}
}

@incollection{Chu-Carroll2003,
abstract = {In recent years, new software development methodologies and styles have become popular. In particular, many applications are being developed in the open-source community by groups of loosely coordinated programmers scattered across the globe. This style of widely distributed collaboration creates a suite of new problems for software development. Instead of being able to knock on the door of a collaborator, all communication between programmers working together on a system must be mediated through the computer. But at the same time, the bandwidth available for communication is dramatically more limited than those available to local collaborators. In this paper, we present a new SCM system called Stellation which is specifically designed to address the limits of current SCM systems, particularly when those systems are applied to large projects developed in a geographically distributed environment. Stellation attempts to enhance communication and collaboration between programmers by providing a mechanism called multidimensionality that allows them to share viewpoints on the structure and organization of the system; by providing a hierarchical branching mechanism that allows the granularity of coordination to be varied for different purposes; and by providing a mechanism for integrating programming language knowledge into the system, allowing it to be used for organizational and coordination purposes.},
author = {Chu-Carroll, MarkC. and Wright, James},
booktitle = {Software Configuration Management},
doi = {10.1007/3-540-39195-9\_4},
file = {:D$\backslash$:/Mendeley Desktop/chp\%3A10.1007\%2F3-540-39195-9\_4.pdf:pdf},
isbn = {978-3-540-14036-8},
language = {English},
pages = {40--53},
publisher={Springer},
title = {{Supporting Distributed Collaboration through Multidimensional Software Configuration Management}},
volume = {2649},
year = {2003}
}

@inproceedings{Perry1987,
abstract = {In current change management tools, the actual changes occur outside the tool. In contrast, Infuse concentrates on the actual change process and provides facilities for both managing and coordinating source changes. Infuse provides facilities for automatically structuring the cooperation among programmers, propagating changes, and determining the consistency of changes, and provides a basis for negotiating the resolution of conflicting changes and for iterating over a set of changes.},
author = {Perry, Dewayne E. and Kaiser, Gail E.},
booktitle = {CSC '87},
doi = {10.1145/322917.322963},
file = {:D$\backslash$:/Mendeley Desktop/p292-perry.pdf:pdf},
isbn = {0897912187},
keywords = {bariknier15,version control},
mendeley-tags = {bariknier15,version control},
month = feb,
pages = {292--299},
title = {{Infuse: a tool for automatically managing and coordinating source changes in large systems}},
year = {1987}
}

@inproceedings{Perry1989,
address = {New York, New York, USA},
author = {Perry, Dewayne E.},
booktitle = {ICSE '89},
doi = {10.1145/74587.74588},
file = {:D$\backslash$:/Mendeley Desktop/p2-perry.pdf:pdf},
isbn = {0818619414},
keywords = {bariknier15},
mendeley-tags = {bariknier15},
month = may,
pages = {2--11},
title = {{The Inscape environment}},
year = {1989}
}

@inproceedings{Ying2011a,
abstract = {Programmers performing a change task must understand the existing software in addition to performing the actual change. This process is likely to be affected by characteristics of the task. We investigated whether the nature of a task has any relationship with when a programmer edits code during a programming session. We characterized differences in editing behaviour with three types of editing styles: edit-first, edit-last, and edit-throughout. We based our analysis on the interaction history of over 4000 programming sessions collected as part of the development history of open source projects. Our results showed that an enhancement task (as opposed to a bug fix) was less likely to be associated with a high fraction of source code edit events at the beginning of the programming session. To our surprise, we also found that the presence of a stack trace in a bug report did not significantly effect the editing style of the programming session.},
author = {Ying, Annie T.T. and Robillard, Martin P.},
booktitle = {2011 IEEE 19th International Conference on Program Comprehension},
doi = {10.1109/ICPC.2011.35},
file = {:D$\backslash$:/Mendeley Desktop/05970161.pdf:pdf},
isbn = {978-1-61284-308-7},
issn = {1092-8138},
keywords = {Clustering algorithms,Couplings,Development interaction history,History,Mining software archives,Monitoring,Navigation,Program comprehension,Programming,Software,bariknier15,behavioural sciences,bug fix,bug report,development history,edit-first style,edit-last style,edit-throughout style,editing behaviour,editing style,enhancement task,icpc,icpc2011,interaction history,open source projects,program debugging,programmer behaviour,programming,programming session,software engineering,source code editing,stack trace},
mendeley-tags = {bariknier15,icpc,icpc2011},
month = jun,
pages = {31--40},
publisher = {IEEE},
shorttitle = {Program Comprehension (ICPC), 2011 IEEE 19th Inter},
title = {{The Influence of the Task on Programmer Behaviour}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=5970161},
year = {2011}
}

@inproceedings{Wang2011,
abstract = {With the goal of increasing program readability for easier understanding, coding guidelines often include formatting standards such as indenting loop and conditional branch body statements. Similarly, good programming practice suggests that programmers use blank lines to visibly delineate between code segments that represent different algorithmic steps or high level actions. Unfortunately, programmers do not always follow these guidelines. While editors and IDEs can easily indent code based on syntax, they do not currently support automatic blank line insertion, which presents more significant challenges involving the semantics. This paper presents a heuristic solution to the automatic blank line insertion problem, by leveraging both program structure and naming information to identify "meaningful blocks", consecutive statements that logically implement a high level action. Our tool, SEGMENT, takes as input a Java method, and outputs a segmented version that separates meaningful blocks by vertical spacing. We report on an evaluation of the effectiveness of SEGMENT based on developers' opinions. SEGMENT assists in making users obtain an overall picture of a method's actions and comprehend it quicker r as well as provides hints for internal documentation placement.},
author = {Wang, Xiaoran and Pollock, Lori and Vijay-Shanker, K.},
booktitle = {Working Conference on Reverse Engineering},
doi = {10.1109/WCRE.2011.15},
file = {:D$\backslash$:/Mendeley Desktop/06079773.pdf:pdf},
isbn = {978-1-4577-1948-6},
issn = {1095-1350},
keywords = {Compounds,Encoding,Humans,IDE,Java,Java method,Reverse engineering,SEGMENT,Semantics,Syntactics,automatic blank line insertion problem,automatic formatting,automatic method code segmentation,bariknier15,blank lines,conditional branch body statements,document handling,formatting standards,indenting loop,internal documentation placement,program compilers,program readability,program understanding,readability,software maintenance,software tool,source coding},
language = {English},
mendeley-tags = {bariknier15},
month = oct,
pages = {35--44},
title = {{Automatic Segmentation of Method Code into Meaningful Blocks to Improve Readability}},
year = {2011}
}

@article{Murphy-Hill2012c,
abstract = {Refactoring is widely practiced by developers, and considerable research and development effort has been invested in refactoring tools. However, little has been reported about the adoption of refactoring tools, and many assumptions about refactoring practice have little empirical support. In this paper, we examine refactoring tool usage and evaluate some of the assumptions made by other researchers. To measure tool usage, we randomly sampled code changes from four Eclipse and eight Mylyn developers and ascertained, for each refactoring, if it was performed manually or with tool support. We found that refactoring tools are seldom used: 11 percent by Eclipse developers and 9 percent by Mylyn developers. To understand refactoring practice at large, we drew from a variety of data sets spanning more than 39,000 developers, 240,000 tool-assisted refactorings, 2,500 developer hours, and 12,000 version control commits. Using these data, we cast doubt on several previously stated assumptions about how programmers refactor, while validating others. Finally, we interviewed the Eclipse and Mylyn developers to help us understand why they did not use refactoring tools and to gather ideas for future research.},
author = {Murphy-Hill, Emerson and Parnin, Chris and Black, Andrew P.},
doi = {10.1109/TSE.2011.41},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Murphy-Hill, Parnin, Black - 2012 - How We Refactor, and How We Know It.pdf:pdf},
issn = {0098-5589},
journal = {IEEE Transactions on Software Engineering},
keywords = {Eclipse developers,Java,Mylyn developers,Refactoring,Software tools,bariknier15,floss refactoring,randomly sampled code,refactor,refactoring tools,research and development,root-canal refactoring.,software engineering,software maintenance},
mendeley-tags = {bariknier15,refactor,software engineering},
month = jan,
number = {1},
pages = {5--18},
shorttitle = {Software Engineering, IEEE Transactions on},
title = {{How We Refactor, and How We Know It}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=6112738},
volume = {38},
year = {2012}
}

@incollection{Negara2012,
abstract = {Researchers use file-based Version Control System (VCS) as the primary source of code evolution data. VCSs are widely used by developers, thus, researchers get easy access to historical data of many projects. Although it is convenient, research based on VCS data is incomplete and imprecise. Moreover, answering questions that correlate code changes with other activities (e.g., test runs, refactoring) is impossible. Our tool, CodingTracker, non-intrusively records fine-grained and diverse data during code development. CodingTracker collected data from 24 developers: 1,652 hours of development, 23,002 committed files, and 314,085 testcase runs. This allows us to answer: How much code evolution data is not stored in VCS? How much do developers intersperse refactorings and edits in the same commit? How frequently do developers fix failing tests by changing the test itself? How many changes are committed to VCS without being tested? What is the temporal and spacial locality of changes?},
author = {Negara, Stas and Vakilian, Mohsen and Chen, Nicholas and Johnson, RalphE. and Dig, Danny},
booktitle = {ECOOP 2012 – Object-Oriented Programming SE - 5},
doi = {10.1007/978-3-642-31057-7\_5},
editor = {Noble, James},
file = {:D$\backslash$:/Mendeley Desktop/chp\%3A10.1007\%2F978-3-642-31057-7\_5.pdf:pdf},
isbn = {978-3-642-31056-0},
keywords = {bariknier15},
language = {English},
mendeley-tags = {bariknier15},
pages = {79--103},
publisher = {Springer Berlin Heidelberg},
series = {Lecture Notes in Computer Science},
title = {{Is It Dangerous to Use Version Control Histories to Study Source Code Evolution?}},
url = {http://dx.doi.org/10.1007/978-3-642-31057-7\_5},
volume = {7313},
year = {2012}
}

@inproceedings{Robbes2008,
abstract = {Our research is driven by the motivation that change must be put in the center, if one wants to understand the complex processes of software evolution. We built a toolset named SpyWare which, using a monitoring plug-in for integrated development environments (IDEs), tracks the changes that a developer performs on a program as they happen. SpyWare stores these first-class changes in a change repository and offers a plethora of productivity-enhancing IDE extensions to exploit the recorded information.},
address = {New York, New York, USA},
author = {Robbes, Romain and Lanza, Michele},
booktitle = {Proceedings of the 13th international conference on Software engineering - ICSE '08},
doi = {10.1145/1368088.1368219},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Robbes, Lanza - 2008 - SpyWare.pdf:pdf},
isbn = {9781605580791},
keywords = {bariknier15,change,modelling,program transformation,visualization},
mendeley-tags = {bariknier15},
month = may,
pages = {847},
publisher = {ACM Press},
title = {{SpyWare}},
url = {http://dl.acm.org/citation.cfm?id=1368088.1368219},
year = {2008}
}

@book{Loeliger2012,
author = {Loeliger, Jon and McCullough, Matthew},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Loeliger, McCullough - 2012 - Version Control with Git.pdf:pdf},
isbn = {9781449316389},
keywords = {book,git},
mendeley-tags = {book,git},
publisher = {O'Reilly Media, INc.},
title = {{Version Control with Git}},
year = {2012}
}

@inproceedings{Hayashi2012,
abstract = {This paper proposes a concept for refactoring an edit history of source code and a technique for its automation. The aim of our history refactoring is to improve the clarity and usefulness of the history without changing its overall effect. We have defined primitive history refactorings including their preconditions and procedures, and large refactorings composed of these primitives. Moreover, we have implemented a supporting tool that automates the application of history refactorings in the middle of a source code editing process. Our tool enables developers to pursue some useful applications using history refactorings such as task level commit from an entangled edit history and selective undo of past edit operations.},
author = {Hayashi, Shinpei and Omori, Takayuki and Zenmyo, Teruyoshi and Maruyama, Katsuhisa and Saeki, Motoshi},
booktitle = {2012 28th IEEE International Conference on Software Maintenance (ICSM)},
doi = {10.1109/ICSM.2012.6405336},
file = {:D$\backslash$:/Mendeley Desktop/06405336.pdf:pdf},
isbn = {978-1-4673-2312-3},
issn = {1063-6773},
keywords = {Browsers,Conferences,Electronic mail,History,Software maintenance,Usability,bariknier15,configuration management,edit history,edit operation selective undo,history clarity improvement,history usefulness improvement,refactoring,software configuration management,software maintenance,source code edit primitive history refactoring,task level commit},
mendeley-tags = {bariknier15},
month = sep,
pages = {617--620},
publisher = {IEEE},
shorttitle = {Software Maintenance (ICSM), 2012 28th IEEE Intern},
title = {{Refactoring edit history of source code}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=6405336},
year = {2012}
}

@article{Weiser1982a,
abstract={Computer programmers break apart large programs into smaller coherent pieces. Each of these pieces: functions, subroutines, modules, or abstract datatypes, is usually a contiguous piece of program text. The experiment reported here shows that programmers also routinely break programs into one kind of coherent piece which is not coniguous. When debugging unfamiliar programs programmers use program pieces called slices which are sets of statements related by their flow of data. The statements in a slice are not necessarily textually contiguous, but may be scattered through a program.},
  title={Programmers use slices when debugging},
  author={Weiser, Mark},
  journal={Communications of the ACM},
  volume={25},
  number={7},
  pages={446--452},
  year={1982},
  publisher={ACM}
}


@inproceedings{Deline2012DebuggerCanvas,
abstract={At ICSE 2010, the Code Bubbles team from Brown University and the Code Canvas team from Microsoft Research presented similar ideas for new user experiences for an integrated development environment. Since then, the two teams formed a collaboration, along with the Microsoft Visual Studio team, to release Debugger Canvas, an industrial version of the Code Bubbles paradigm. With Debugger Canvas, a programmer debugs her code as a collection of code bubbles, annotated with call paths and variable values, on a two-dimensional pan-and-zoom surface. In this experience report, we describe new user interface ideas, describe the rationale behind our design choices, evaluate the performance overhead of the new design, and provide user feedback based on lab participants, post-release usage data, and a user survey and interviews. We conclude that the code bubbles paradigm does scale to existing customer code bases, is best implemented as a mode in the existing user experience rather than a replacement, and is most useful when the user has a long or complex call paths, a large or unfamiliar code base, or complex control patterns, like factories or dynamic linking.},
  title={Debugger canvas: industrial experience with the code bubbles paradigm},
  author={DeLine, Robert and Bragdon, Andrew and Rowan, Kael and Jacobsen, Jens and Reiss, Steven P},
  booktitle={ICSE '12},
  pages={1064--1073},
  year={2012},
  organization={IEEE Press}
}

@inproceedings{DeLine2010a,
abstract = {The user interfaces of today's development environments have a "bento box" design that partitions information into separate areas. This design makes it difficult to stay oriented in the open documents and to synthesize information shown in different areas. Code Canvas takes a new approach by providing an infinite zoomable surface for software development. A canvas both houses editable forms of all of a project's documents and allows multiple layers of visualization over those documents. By uniting the content of a project and information about it onto a single surface, Code Canvas is designed to leverage spatial memory to keep developers oriented and to make it easy to synthesize information.},
address = {New York, New York, USA},
author = {DeLine, Robert and Rowan, Kael},
booktitle = {Proceedings of the 32nd ACM/IEEE International Conference on Software Engineering - ICSE '10},
doi = {10.1145/1810295.1810331},
file = {:C$\backslash$:/Users/tbarik/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/DeLine, Rowan - 2010 - Code canvas zooming towards better development environments.pdf:pdf},
isbn = {9781605587196},
keywords = {code bubbles,code canvas,software engineering},
mendeley-tags = {code bubbles,code canvas,software engineering},
month = may,
pages = {207},
publisher = {ACM Press},
title = {{Code canvas: zooming towards better development environments}},
url = {http://dl.acm.org.prox.lib.ncsu.edu/citation.cfm?id=1810295.1810331},
volume = {2},
year = {2010}
}

@inproceedings{Bragdon2010CodeBubbles,
  title={Code bubbles: rethinking the user interface paradigm of integrated development environments},
  author={Bragdon, Andrew and Reiss, Steven P and Zeleznik, Robert and Karumuri, Suman and Cheung, William and Kaplan, Joshua and Coleman, Christopher and Adeputra, Ferdi and LaViola Jr, Joseph J},
  booktitle={ICSE '10},
  pages={455--464},
  year={2010},
  organization={ACM}
}

@book{beck2003tdd,
  title={Test-driven development: by example},
  author={Beck, Kent},
  year={2003},
  publisher={Addison-Wesley Professional}
}